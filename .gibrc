#!/bin/sh
[ -z "$PS1" ] && return # Exit if not running interactively
echo "Using gibrc..."

## Define variables to use later
HOSTNAME=$(hostname)
UNAME=$(uname)
UNAMEN=$(uname -n)

if [ -n "$ZSH_VERSION" ]; then # assume zsh
  CASE_SENSITIVE="true"
  HYPHEN_INSENSITIVE="true"
  chpwd() { ls; } # Add ls after changing directory
  DISABLE_AUTO_TITLE="true"
  zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}'
  #  fpath+=~/.zfunc # Put autocomplete scripts in here
elif [ -n "$BASH_VERSION" ]; then # assume Bash ## Shell basics
  shopt -s autocd # type directory name to cd
  ls --color=auto >/dev/null 2>&1 && alias ls='ls --color=auto' # ls uses colour where possible
  [ "$UNAME" = "Darwin" ] && alias ls='ls -G' # coloured prompt on macOS
  alias la='ls -A' # List hidden files as well
  alias ll='ls -l' # Gives more detail about files
  alias lal='ls -al' # More detail and hidden files
  alias l='ls -CF' # List column sorted with indicators
  cs() { cd "$@" && ls; } # cs => cd and ls
  alias ..='cs ..' # .. goes up a directory
  alias ...='cs ../..' # ... goes up two directories
  alias ....='cs ../../..'
  alias .....='cs ../../../..'
  alias ......='cs ../../../../..'
  bind Space:magic-space 2>/dev/null # !31 (execute command from history) autoexpands on space
  bind 'set completion-ignore-case on' 2>/dev/null # case-insensitive tab completion
  PS1=' \[\e[32;1m\]\w $ \[\e[0m\]'
fi

## Other shell bits
export VISUAL=vim # Set vim as the default editor
alias path='echo $PATH'
alias x="exit" # x exits the terminal
alias c="clear" # c clears the terminal screen
alias h=history # shows a history of commands
alias s="ssh" # Won't prompt with "add new RSA key" if you use -oStrictHostKeyChecking=No
alias np="ps -ef|wc -l"             # np - number of processes running
ulimit -c unlimited # Allow saving of coredumps

## Git commands
alias gs="git status"
alias gl="git log --graph --decorate --oneline" # Graph of commits
alias gla="git log --graph --decorate --oneline --all" # Graph of commits for all branches
alias gll="git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creseti \
  %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit" # prettier graph
alias gf="git fetch"
alias gfa="git fetch --all"
alias gco="git checkout"
alias gcp="git cherry-pick"
# Set up local branch from Github PR, e.g. gfp origin 7654
gfp() { git fetch $1 pull/$2/head:pr-$2; } # $1: remote name, $2: PR number 
gpp() { # Update branch created with gfp, $1: remote name
  pr=`git symbolic-ref --short HEAD | cut -d "-" -f 2` # Assumes pr-7654 style branch
  git pull $1 pull/$pr/head 
}


## Useful functions (use the same way as aliases)
pathadd() { # Add something to the path
    [ -d "$1" ] && [[ ":$PATH:" != *":$1:"* ]] && PATH="$1${PATH+":$PATH"}"
}

fnd() { # Recursive case-insensitive filename search (use grep -r for contents)
    find . -iname "*$**"
}

pth() { # Returns absolute path to file including file name
  # $1: relative filename, return: absolute path
  for i in "$@"; do
    if [ -d "$i" ]; then (cd "$i"; pwd) # dir
    elif [ -f "$i" ]; then  # file
      if [[ $i == */* ]]; then echo "$(cd "${i%/*}"; pwd)/${i##*/}"
      else echo "$(pwd)/$i"
      fi
    fi
  done
}

## Rust commands
alias cn="cargo new --bin" # Create new cargo module
alias cb="cargo build"
alias cr="cargo run"
alias ct="cargo test"
alias ctag='ctags -R . $HOME/bin/src/rust' # Populate ctags from rust src
alias ru=rustup
# Compile and execute all args (e.g. "rs a.rs b")
rs() {
  for i in $@; do
    rustc ${i%.rs}.rs
    ./${i%.rs}
  done
}

alias busy='cat /dev/urandom | hexdump -C | grep "ca fe"' # Makes it look like you're busy

[ "$HOSTNAME" = "glub" ] && alias mnt='sudo mount -t vboxsf ForVM ~/shared/'

# Build node with ninja
alias bn='./configure && tools/gyp_node.py -f ninja && ninja -C out/Release && ln -fs out/Release/node node'

alias bashme="PS1='\[\e[35;1m\]\h \n \w $ \[\e[0m\]'" # In case prompt wasn't set automatically
## Set prompt for different shells
if [ -n "$SSH_CLIENT" ] || [ -n "$SSH_TTY" ]; then
  if [ -n "$BASH_VERSION" ]; then # assume Bash ## Shell basics
    PS1='\[\e[35;1m\]\h \n \w $ \[\e[0m\]'
  else
    myshell=dash
    myshell=${myshell:-"$(ls -l /proc/$$/exe | sed 's%.*/%%')"}
    case $0 in
    -ksh) myshell=ksh;;
    -sh) myshell=dash;;
    esac
    if [ "$myshell" = "ksh93" ]; then
      PS1='\E[35;1m $HOSTNAME \n $PWD \E[0m $ '
    else
      PS1="$UNAMEN $PWD $ "
    fi
  fi
fi
# Enable basic keys on ancient shells
if [ "$myshell" = "ksh93" -o "$myshell" = "ksh" ]; then
  set -o emacs
  alias __A=`echo "\020"`     # up arrow = ^p = back a command
  alias __B=`echo "\016"`     # down arrow = ^n = down a command
  alias __C=`echo "\006"`     # right arrow = ^f = forward a character
  alias __D=`echo "\002"`     # left arrow = ^b = back a character
  alias __H=`echo "\001"`     # home = ^a = start of line
  alias __Y=`echo "\6"`     # end = ^e = end of line
fi

## Optional extras
exists() { type "$1" >/dev/null 2>&1; }
exists thefuck && eval $(thefuck --alias) && alias f='fuck' # github.com/nvbn/thefuck
if [ -d "$HOME/.nvm" ]; then # Setup nvm
  export NVM_DIR="$HOME/.nvm"
  if exists brew; then
    . "$(brew --prefix nvm)/nvm.sh"
  elif [ -s "$NVM_DIR/nvm.sh" ]; then
    . "$NVM_DIR/nvm.sh"
  fi
fi

## Add things to the path
pathadd "$HOME/.cargo/bin"
