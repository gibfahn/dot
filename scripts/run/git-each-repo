#!/usr/bin/env bash

set -euo pipefail

# Things that I want to do to every git repository, every time.

main() {
  # Add repo to my zoxide search path without increasing its score.
  zoxide add --score 0.0 "$PWD"

  config_file=~/.config/git/maintenance.config

  # Get realpath of current directory.
  current_dir=$(pwd -P)

  check_dir

  # Add git repo to maintenance list to be automatically kept up-to-date.
  if ! grep -qF "$current_dir" "$config_file"; then
    echo "  repo = $current_dir" >>"$config_file"
    if ! grep -qF "$current_dir" "$config_file"; then
      echo "Something went wrong, failed to add '$current_dir' to '$config_file'"
      exit 1
    fi
  fi

  # Rename any legacy `up` remotes to `origin`
  if git remote | grep -qx up; then
    if git remote | grep -qx origin; then
      if [[ "$(git remote get-url up)" == "$(git remote get-url origin)" ]]; then
        echo "up and origin remotes both exist and point to the same remote, deleting..."
        git remote rm up
      else
        error "Can't rename up remote -> origin as origin also exists!"
      fi
    fi
    echo "Changed remote up -> origin"
    git remote rename up origin
  fi

  # Sync the remote branch of any fork repo to the upstream.
  # This prevents git pushes to your fork taking a long time if much git history has been pushed since
  # you last pushed fork/forkmain.
  # This assumes that your fork main branch is called `forkmain`, which mine always are.
  for remote in $(git remote | grep fork); do
    if [[ $(git remote get-url "$remote") == *github*gib* ]]; then
      # If this fails with:
      # HTTP 404: Not Found (https://github.com/api/v3/repos/upstream-org/upstream-repo/git/refs/heads/forkmain)
      # Then try it in the UI, that usually fails with "forkmain has commits not in upstream" (which
      # you can fix in the UI by discarding those commits).
      GH_HOST=$(git parse-url --quiet --remote "$remote" --segment host) gh repo sync "$(git parse-url --quiet --remote "$remote" --segment org-repo)" --branch forkmain
    fi
  done

  # Set a default repo if there's an obvious one present. I use `origin` as my default upstream repo name,
  # so if it exists it's a good option. We only want to do this for github repos though.
  # stdout is empty for `gh repo set-default --view` when a default hasn't been set.
  if [[ $(git remote get-url origin) == *github* ]]; then
    update_if_repo_url_changed
    if [[ -z $(gh repo set-default --view 2>/dev/null) ]]; then
      set_gh_default_repo
    fi
  fi

  # Run work script if present.
  wrk_script=${wrk_dot_dir:-}/scripts/run/git-each-repo-wrk
  if [[ -f ${wrk_dot_dir:-}/scripts/run/git-each-repo-wrk ]]; then
    "$wrk_script"
  fi

  # Update repo and prune any merged branches.
  git fetch --all --quiet
  git bp --quiet
  git mf >&/dev/null || true

  # Check for unpushed branches or uncommitted changes.
  git unpushed
}

# If the remote URL changes, e.g. from `https://github.com/oldorg/oldrepo` ->
# `https://github.com/neworg/newrepo`, then we need to update the remote URL, and possibly move the
# repo entirely.
# This needs to be done before `gh repo set-default`, as that errors if the provided URL doesn't
# match the renamed URL.
update_if_repo_url_changed() {
  current_origin_url=$(git remote get-url origin)
  new_origin_url=$(GH_HOST=$(git parse-url --quiet --segment host) gh repo view --json url --jq .url "$current_origin_url")

  # Ignore trailing slashes in URLs like https://github.com/gibfahn/dot/
  current_origin_url=${current_origin_url%/}

  if [[ "${current_origin_url%.git}" == "${new_origin_url%.git}" ]]; then
    return
  fi

  current_origin_org_repo=$(git parse-url --quiet --segment org-repo)

  # Update repo URL.
  git remote set-url origin "$new_origin_url"
  new_origin_org_repo=$(git parse-url --quiet --segment org-repo)

  # This means that the upstream repo name has changed and we should move it.
  if [[ "$PWD" == *"${current_origin_org_repo}" ]]; then
    new_path=${PWD%"/$current_origin_org_repo"}/"$new_origin_org_repo"
    mkdir -p "$(dirname "$new_path")"
    mv -v "$PWD" "$new_path"
    cd "$new_path"
    echo "Fixed path to updated repo to ${new_path}"
  fi
}

# Set the default repo for gh to work with.
set_gh_default_repo() {
  # We have to set GH_HOST as otherwise if there are two different versions of a repo (e.g.
  # github.com/foo/bar and github.mycorp.com/foo/bar), gh will get confused.
  GH_HOST=$(git parse-url --quiet --segment host) gh repo set-default "$(git remote get-url origin)"
}

# Check that we're not in a git repo inside another git repo.
check_dir() {
  local cur_dir=$PWD
  while [[ "$cur_dir" != / ]]; do
    cur_dir=$(dirname "$cur_dir")
    if [[ -d "$cur_dir"/.git/ ]]; then
      # We're in a git repo inside a git repo, so assume it is managed by the parent and don't do
      # anything.
      exit 0
    fi
  done
}

# Usage: exit message [rc]
error() {
  local RED='\033[0;31m' NC='\033[0m'
  echo -e "${RED}Error:${NC} $1"
  exit "${2:-1}"
}

main "$@"
